#!/usr/bin/env python
"""
Script to automatically generate __init__.py files for each subpackage under nirs4all
Scans for class definitions, function definitions, and constants, and writes import statements in __init__.py
Usage: python generate_init.py
"""
import ast
import os
import re

dir_path = os.path.dirname(os.path.abspath(__file__))
globals()['ROOT'] = os.path.join(dir_path, 'nirs4all')
# Directory containing this script
script_dir = os.path.dirname(os.path.abspath(__file__))
# Root package directory under this workspace (nirs4all/nirs4all)
ROOT = os.path.join(script_dir, 'nirs4all')

def extract_public_names(file_path):
    """Extract public classes, functions, and constants from a Python file."""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            tree = ast.parse(f.read())
    except (SyntaxError, UnicodeDecodeError):
        return []

    names = []
    for node in ast.walk(tree):
        if isinstance(node, ast.ClassDef):
            # Only include public classes (not starting with _)
            if not node.name.startswith('_'):
                names.append(node.name)
        elif isinstance(node, ast.FunctionDef):
            # Only include public functions (not starting with _)
            if not node.name.startswith('_'):
                names.append(node.name)
        elif isinstance(node, ast.Assign):
            # Extract constants (uppercase variables)
            for target in node.targets:
                if isinstance(target, ast.Name) and isinstance(target.ctx, ast.Store):
                    if (target.id.isupper() and not target.id.startswith('_')):
                        names.append(target.id)

    return names

for dirpath, dirnames, filenames in os.walk(ROOT):
    # Skip hidden directories and __pycache__
    if any(part.startswith('.') or part == '__pycache__' for part in dirpath.split(os.sep)):
        continue

    # Skip certain directories that shouldn't have auto-generated __init__.py
    skip_dirs = ['__pycache__', 'tests', '.pytest_cache']
    if any(skip_dir in dirpath for skip_dir in skip_dirs):
        continue

    # Collect .py files except __init__.py
    py_files = [f for f in filenames if f.endswith('.py') and f != '__init__.py']
    imports = []
    all_names = []

    for fname in py_files:
        module = os.path.splitext(fname)[0]
        file_path = os.path.join(dirpath, fname)

        # Extract all public names from the file
        public_names = extract_public_names(file_path)

        if public_names:
            # Create import statement
            imports.append(f'from .{module} import {", ".join(public_names)}')
            all_names.extend(public_names)

    # Write __init__.py only if we have imports
    if imports:
        init_file = os.path.join(dirpath, '__init__.py')
        with open(init_file, 'w', encoding='utf-8') as initf:
            initf.write('# Auto-generated by generate_init.py\n')
            for imp in sorted(imports):
                initf.write(imp + '\n')

            # Add __all__ list
            if all_names:
                initf.write('\n__all__ = [\n')
                for name in sorted(set(all_names)):
                    initf.write(f"    '{name}',\n")
                initf.write(']\n')
    else:
        # Create minimal __init__.py for packages with no public exports
        init_file = os.path.join(dirpath, '__init__.py')
        if not os.path.exists(init_file):
            with open(init_file, 'w', encoding='utf-8') as initf:
                initf.write('# Auto-generated by generate_init.py\n# No public classes or functions to import\n')
